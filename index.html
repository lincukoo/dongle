<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HA Dongle Flasher — sl-web-tools 风格复刻</title>
<style>
/* 仿 sl-web-tools 简洁专业样式 */
:root{--bg:#0b1220;--panel:#0e1724;--muted:#9aa4b2;--accent:#4488ff;--accent2:#00d1b2}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;color:#e6eef6;background:linear-gradient(180deg,#061226 0%,#02101a 100%);min-height:100vh}
.container{max-width:1100px;margin:28px auto;padding:18px}
.header{display:flex;align-items:center;gap:16px}
.logo{width:56px;height:56px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#6aa7ff);display:flex;align-items:center;justify-content:center;font-weight:700;color:#02101a}
.title{font-size:18px;margin:0}
.subtitle{color:var(--muted);font-size:13px;margin-top:4px}
.layout{display:grid;grid-template-columns:320px 1fr;gap:16px;margin-top:18px}
.card{background:var(--panel);border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,0.03)}
.sidebar .section{margin-bottom:12px}
.btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:inherit;cursor:pointer}
.btn.primary{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#02101a;border:none}
.field{display:flex;gap:8px;align-items:center;margin:8px 0}
.select, input[type='text']{flex:1;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
.fw-list{max-height:320px;overflow:auto;border-radius:6px;border:1px dashed rgba(255,255,255,0.02);padding:6px}
.fw-item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:6px}
.fw-item:hover{background:rgba(255,255,255,0.01)}
.controls{display:flex;gap:8px}
.main .top{display:flex;justify-content:space-between;align-items:center;gap:12px}
.panel-row{display:flex;gap:12px;margin-top:12px}
.terminal{background:#000;padding:12px;border-radius:8px;height:320px;overflow:auto;font-family:monospace;font-size:13px;color:#bfe8ff}
.progress-wrap{margin-top:8px}
progress{width:100%;height:12px;border-radius:8px}
.muted{color:var(--muted);font-size:13px}
.footer{margin-top:12px;color:var(--muted);font-size:13px}
@media (max-width:960px){.layout{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="logo">sl</div>
    <div>
      <h1 class="title">HA Dongle Flasher — sl-web-tools 样式复刻</h1>
      <div class="subtitle">支持 EFR32MG21 · Gecko Bootloader (.gbl) · WebSerial · XMODEM-1K</div>
    </div>
  </div>

  <div class="layout">
    <div class="sidebar card">
      <div class="section">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="muted">串口</div>
          <div id="portState" class="muted">未连接</div>
        </div>
        <div class="field" style="margin-top:8px">
          <button id="btnConnect" class="btn">连接</button>
          <select id="baud" class="select"><option>115200</option><option>230400</option><option>460800</option></select>
        </div>
      </div>

      <div class="section">
        <div class="muted">固件源 (lincukoo/USB-Dongle · firmware/Dongle-MG21)</div>
        <div class="field" style="margin-top:8px">
          <input id="fwUrl" class="select" placeholder="固件 URL（优先于本地）"/>
        </div>
        <div class="field">
          <input id="fwFile" type="file" accept=".gbl,.bin"/>
        </div>
        <div class="field controls">
          <button id="btnRefresh" class="btn">刷新</button>
          <button id="btnLatest" class="btn">选最新</button>
          <button id="btnAutoBoot" class="btn">尝试 RTS/DTR</button>
        </div>
        <div class="fw-list" id="fwList"></div>
      </div>

      <div class="section">
        <div class="muted">高级</div>
        <div style="margin-top:8px" class="field">
          <label class="muted" style="width:100px">重试次数</label>
          <input id="retry" type="text" value="8" style="width:60px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit"/>
        </div>
      </div>
    </div>

    <div class="main">
      <div class="card">
        <div class="top">
          <div style="display:flex;gap:8px;align-items:center">
            <button id="btnFlash" class="btn primary" disabled>开始刷机</button>
            <div class="muted">选择固件后启用</div>
          </div>
          <div class="muted">传输: XMODEM-1K (CRC)</div>
        </div>

        <div class="panel-row">
          <div style="flex:1">
            <div class="muted">进度</div>
            <div class="progress-wrap"><progress id="progress" value="0" max="100"></progress></div>
            <div style="height:10px"></div>
            <div class="muted">终端日志</div>
            <div id="terminal" class="terminal"></div>
          </div>
        </div>

        <div class="footer">说明：先把 Dongle 置入 Gecko Bootloader（按住 BOOT 并上电），或使用 RTS/DTR 自动（需连线）。不要在刷机过程中拔掉设备。</div>
      </div>
    </div>
  </div>
</div>

<script>
/* 复刻 sl-web-tools 的行为：
   - 自动拉取 GitHub 固件列表
   - 支持选择本地文件或 URL
   - WebSerial 连接
   - XMODEM-1K 发送实现
*/

const API = 'https://api.github.com/repos/lincukoo/USB-Dongle/contents/firmware/Dongle-MG21';
const fwListEl = document.getElementById('fwList');
const terminal = document.getElementById('terminal');
const btnRefresh = document.getElementById('btnRefresh');
const btnConnect = document.getElementById('btnConnect');
const btnFlash = document.getElementById('btnFlash');
const btnLatest = document.getElementById('btnLatest');
const btnAutoBoot = document.getElementById('btnAutoBoot');
const portState = document.getElementById('portState');
const progress = document.getElementById('progress');
const fwUrlInput = document.getElementById('fwUrl');
const fwFileInput = document.getElementById('fwFile');
const baudSelect = document.getElementById('baud');

let port=null, writer=null, reader=null, firmwareFiles=[];

function term(msg){ terminal.textContent += msg + '
'; terminal.scrollTop = terminal.scrollHeight; }
function shortName(n){ return n.length>36 ? n.slice(0,20)+'...'+n.slice(-12) : n }

async function fetchList(){
  fwListEl.innerHTML = '<div class="muted">加载中…</div>';
  try{
    const r = await fetch(API);
    if(!r.ok) throw new Error(r.status);
    const data = await r.json();
    firmwareFiles = data.filter(f => f.name && (f.name.endsWith('.gbl')||f.name.endsWith('.bin')))
      .map(f => ({name:f.name, url:f.download_url, size:f.size, sha:f.sha}))
      .sort((a,b)=> a.name.localeCompare(b.name, undefined, {numeric:true}));
    renderList(); term('固件列表加载完毕: '+ firmwareFiles.length);
  }catch(e){ fwListEl.innerHTML = '<div class="muted">拉取失败</div>'; term('获取固件列表失败: '+e); }
}
function renderList(){ fwListEl.innerHTML = ''; if(!firmwareFiles.length){ fwListEl.innerHTML='<div class="muted">无固件</div>'; return; } firmwareFiles.forEach((f,idx)=>{ const el=document.createElement('div'); el.className='fw-item'; el.innerHTML = `<div><div style="font-weight:600">${shortName(f.name)}</div><div class="muted">${(f.size/1024).toFixed(1)} KB</div></div>`; const r=document.createElement('div'); const btn=document.createElement('button'); btn.textContent='选择'; btn.onclick = ()=>{ fwUrlInput.value=f.url; Array.from(fwListEl.children).forEach(c=>c.style.background=''); el.style.background='rgba(255,255,255,0.02)'; btnFlash.disabled=false; term('选择: '+f.name); }; r.appendChild(btn); el.appendChild(r); fwListEl.appendChild(el); }); }

btnRefresh.onclick = fetchList; btnLatest.onclick = ()=>{ if(firmwareFiles.length) { const last = firmwareFiles[firmwareFiles.length-1]; fwUrlInput.value = last.url; term('已选择最新: '+ last.name); btnFlash.disabled=false; } };

btnConnect.onclick = async ()=>{
  try{
    port = await navigator.serial.requestPort();
    const baud = parseInt(baudSelect.value||'115200');
    await port.open({ baudRate: baud });
    writer = port.writable.getWriter();
    reader = port.readable.getReader();
    portState.textContent = '已连接 ('+baud+')'; term('串口打开');
  }catch(e){ term('打开串口失败: '+e); }
};

btnAutoBoot.onclick = async ()=>{
  if(!port) return term('请先连接串口');
  if(typeof port.setSignals !== 'function'){ return term('浏览器不支持 setSignals'); }
  try{ term('尝试通过 RTS/DTR 进入 bootloader'); await port.setSignals({ dataTerminalReady:true, requestToSend:true }); await new Promise(r=>setTimeout(r,120)); await port.setSignals({ dataTerminalReady:false, requestToSend:false }); term('已发送信号，请手动重置设备'); }catch(e){ term('自动进入失败: '+e); }
};

// XMODEM implementation
const SOH=0x01, STX=0x02, EOT=0x04, ACK=0x06, NAK=0x15, CAN=0x18, CRC_CHAR=0x43;
function crc16(buf){ let crc=0; for(let i=0;i<buf.length;i++){ crc ^= (buf[i]<<8); for(let j=0;j<8;j++){ crc = (crc & 0x8000) ? ((crc<<1)^0x1021) : (crc<<1); crc &= 0xFFFF } } return crc & 0xFFFF }

async function readByte(timeout=8000){ if(!reader) throw new Error('reader missing'); const p = reader.read(); const t = new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')), timeout)); try{ const {value} = await Promise.race([p,t]); return value && value.length ? value[0] : null; }catch(e){ return null; } }

async function waitInit(timeout=8000){ const start=Date.now(); while(Date.now()-start<timeout){ const b = await readChunk(2000); if(!b) continue; for(const x of b){ if(x===CRC_CHAR) return 'C'; if(x===NAK) return 'NAK'; } } return null }

async function readChunk(timeout=5000){ if(!reader) return null; try{ const p = reader.read(); const t = new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')), timeout)); const {value} = await Promise.race([p,t]); return value || null; }catch(e){ return null } }

async function xmodemSend(bytes, onProgress){ if(!writer) throw new Error('writer missing'); const block = 1024; let offset=0; let blockNum=1; term('等待 bootloader 请求...'); // try to read initial 'C'
  const init = await waitInit(8000); term('初始请求: '+ (init||'无'));
  while(offset < bytes.length){ const chunk = bytes.slice(offset, offset+block); const data = new Uint8Array(block); data.fill(0x1A); data.set(chunk); const crc = crc16(data); const pkt = new Uint8Array(3+block+2); pkt[0]=STX; pkt[1]=blockNum&0xFF; pkt[2]=(~blockNum)&0xFF; pkt.set(data,3); pkt[pkt.length-2]=(crc>>8)&0xFF; pkt[pkt.length-1]=crc&0xFF; let ok=false; let tries=0; while(!ok && tries<8){ tries++; await writer.write(pkt); term('发送区块 '+blockNum+' 尝试 '+tries); const r = await readChunk(8000); const resp = r && r.length ? r[0] : null; if(resp===ACK){ ok=true; term('ACK'); } else if(resp===NAK){ term('NAK'); } else if(resp===CAN){ throw new Error('CAN 收到'); } else term('未知响应:'+resp); }
    if(!ok) throw new Error('区块失败'); offset += block; blockNum = (blockNum % 255) + 1; if(onProgress) onProgress(Math.round(offset/bytes.length*100)); }
  // EOT
  for(let i=0;i<6;i++){ await writer.write(new Uint8Array([EOT])); const r = await readChunk(5000); if(r && r[0]===ACK){ term('EOT 被确认'); return; } }
  throw new Error('EOT 未确认'); }

async function getFirmware(){ const url = fwUrlInput.value.trim(); if(url){ term('下载: '+url); const r = await fetch(url); if(!r.ok) throw new Error('下载失败 '+r.status); const ab = await r.arrayBuffer(); return new Uint8Array(ab); } const f = fwFileInput.files[0]; if(f){ term('读取本地: '+f.name); const ab = await f.arrayBuffer(); return new Uint8Array(ab); } throw new Error('未选择固件'); }

btnFlash.onclick = async ()=>{
  btnFlash.disabled = true; progress.value = 0; try{ const bytes = await getFirmware(); term('固件字节: '+bytes.length); await xmodemSend(bytes, p=>progress.value=p); term('传输完成，等待设备写入...'); }catch(e){ term('刷机失败: '+e); } btnFlash.disabled=false; }

// init
fetchList();

</script>
</body>
</html>
