<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Lincukoo USB-Dongle Firmware upgrade Tool</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
     background:#f5f5f5;color:#333;padding:20px;margin:0}
.container{max-width:800px;margin:auto;background:#fff;border-radius:8px;padding:30px;box-shadow:0 2px 8px rgba(0,0,0,.1)}
h1{text-align:center;margin-bottom:10px;color:#333;font-size:28px;font-weight:600}
.firmware-repo{text-align:center;margin-bottom:8px;font-size:14px}
.firmware-repo:last-of-type{margin-bottom:30px}
.firmware-repo a{color:#2196f3;text-decoration:none;transition:color .3s ease}
.firmware-repo a:hover{color:#1976d2;text-decoration:underline}
.section{background:#fff;border:1px solid #ddd;border-radius:8px;padding:20px;margin-bottom:20px}
.section-title{font-size:18px;font-weight:600;color:#333;margin-bottom:15px}
label{display:block;margin-bottom:8px;color:#333;font-weight:500;font-size:14px}
select,input[type=file]{width:100%;padding:10px 12px;border:1px solid #ddd;border-radius:4px;background:#fff;color:#333;font-size:14px;margin-top:8px}
button{padding:10px 20px;border:none;border-radius:4px;font-size:15px;cursor:pointer;transition:all .3s ease;margin-right:10px;font-weight:500}
.btn-primary{background:#2196f3;color:#fff}
.btn-primary:disabled{background:#ccc;cursor:not-allowed}
.btn-success{background:#4caf50;color:#fff}
.btn-success:hover{background:#45a049}
.btn-danger{background:#f44336;color:#fff}
.btn-danger:hover{background:#da190b}
.btn-chip-active{background:#2196f3!important;color:#fff!important}
.btn-chip-inactive{background:#ccc!important;color:#666!important}
.progress-container{margin-top:20px;display:none}
.progress-bar{width:100%;height:30px;background:#e0e0e0;border-radius:4px;overflow:hidden;position:relative}
.progress-fill{height:100%;background:#ffc107;width:0%;transition:width .3s;position:absolute;left:0;top:0}
.progress-text{position:absolute;right:10px;top:0;line-height:30px;color:#333;font-weight:600;z-index:1}
.status-log{margin-top:20px;height:180px;background:#f9f9f9;border:1px solid #ddd;border-radius:4px;padding:10px;overflow-y:auto;font-family:"Courier New",monospace;font-size:12px;color:#333}
.log-entry{margin-bottom:6px;word-break:break-all}.log-entry.success{color:#4caf50}.log-entry.error{color:#f44336}.log-entry.info{color:#2196f3}
input[type=checkbox]{margin-right:5px;cursor:pointer}
.info-text{color:#666;font-size:13px;margin-top:12px}
.connection-status{background:#e8f5e9;border:1px solid #4caf50;border-radius:4px;padding:12px;margin-top:12px;color:#2e7d32;font-size:14px}
.connection-status.error{background:#ffebee;border-color:#f44336;color:#c62828}
.status-text{margin-bottom:4px}
.chip-info{font-size:12px;color:#666;margin-top:4px}
.connection-help{background:#ffebee;border:1px solid #f44336;border-radius:4px;padding:15px;margin-top:12px;color:#c62828}
.connection-help-title{font-weight:600;font-size:14px;margin-bottom:10px}
.connection-help-item{margin-top:8px;font-size:13px;line-height:1.5}
.connection-help-item::before{content:"• ";margin-right:5px}
.file-info{color:#666;font-size:13px;margin-top:8px}
.upgrade-status{color:#666;font-size:14px;margin-top:12px}
.upgrade-status.success{color:#4caf50;font-weight:600;font-size:16px}
.notice-box{background:#fff3cd;border:1px solid #ffc107;border-radius:4px;padding:15px;margin-top:20px;color:#856404}
.notice-box::before{content:"⚠ ";font-weight:bold;margin-right:5px}
</style>
</head>
<body>
<div class="container">
  <h1>Lincukoo USB-Dongle Firmware upgrade Tool</h1>
  <div class="firmware-repo">
    <strong>Instruction:</strong> 
    <a href="https://github.com/lincukoo/dongle" target="_blank" rel="noopener noreferrer">
      https://github.com/lincukoo/dongle
    </a>
  </div>
  <div class="firmware-repo">
    <strong>Firmware Repository:</strong> 
    <a href="https://github.com/lincukoo/dongle/tree/main/firmware" target="_blank" rel="noopener noreferrer">
      https://github.com/lincukoo/dongle/tree/main/firmware
    </a>
  </div>

  <!-- Device Connection -->
  <div class="section">
    <div class="section-title">Device Connection</div>
    <div id="connectionHelp" class="connection-help">
      <div class="connection-help-title">No port connected</div>
      <div class="connection-help-item">Hold the boot button, insert the dongle, and release the button after 3 seconds, then the dongle enters bootloader mode(the LED should be off);</div>
      <div class="connection-help-item">For Windows/macOS users: Install the USB to Uart Driver to enable device detection.</div>
    </div>
    <div style="margin-top:12px">
      <button class="btn-success" id="btnConn" onclick="connectPort()">Connect</button>
      <button class="btn-danger" id="btnDis" onclick="disconnectPort()" style="display:none">Disconnect</button>
    </div>
    <div id="connectionStatus" style="display:none" class="connection-status">
      <div class="status-text" id="portStatusText"></div>
      <div class="chip-info" id="chipInfo"></div>
      <div id="bootDetectionProgress" style="display:none;margin-top:12px">
        <div style="font-size:13px;margin-bottom:6px;color:#1976d2">Detecting bootloader mode...</div>
        <div class="progress-bar" style="height:20px">
          <div class="progress-fill" id="bootProgBar" style="background:#2196f3"></div>
          <div class="progress-text" id="bootProgText" style="line-height:20px;font-size:12px">0%</div>
        </div>
      </div>
    </div>
    <div id="bootModeError" style="display:none;margin-top:12px;padding:15px;background:#fce4ec;border:1px solid #f48fb1;border-radius:4px;color:#880e4f;font-size:13px;line-height:1.6">
      <div style="font-weight:600;margin-bottom:8px;font-size:14px">Fail to enter bootloader mode</div>
      <div style="margin-top:8px">• Remove the dongle</div>
      <div style="margin-top:8px">• Hold the boot button, insert the dongle, and release the button after 3 seconds, then the dongle enters bootloader mode(the LED should be off);</div>
    </div>
  </div>

  <!-- Select the firmware -->
  <div class="section">
    <div class="section-title">Select the firmware</div>
    <div style="margin-bottom:15px">
      <label style="font-size:14px"><strong>Detected Chip Model</strong>
        <div style="display:flex;gap:6px;margin-top:6px">
          <button type="button" id="btnMG21" class="btn-chip-inactive" style="flex:1;background:#ccc;color:#666;padding:8px 12px;border:none;border-radius:4px;cursor:not-allowed;font-weight:600;font-size:13px" disabled>MG21</button>
          <button type="button" id="btnMG24" class="btn-chip-inactive" style="flex:1;background:#ccc;color:#666;padding:8px 12px;border:none;border-radius:4px;cursor:not-allowed;font-weight:600;font-size:13px" disabled>MG24</button>
        </div>
        <div id="chipAutoDetectInfo" style="margin-top:6px;font-size:12px;color:#666;font-style:italic">Chip model will be automatically detected when entering bootloader mode</div>
      </label>
    </div>
    <div style="margin-bottom:15px">
      <label><strong>Select from GitHub repository</strong>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <select id="verList" style="flex:1"><option value="">Please select chip model first</option></select>
          <button type="button" id="btnRefresh" onclick="loadVersions()" style="background:#2196f3;color:#fff;padding:8px 16px;border:none;border-radius:4px;cursor:pointer;white-space:nowrap">Refresh</button>
        </div>
      </label>
      <!-- Firmware Download Status -->
      <div id="firmwareStatus" style="display:none;margin-top:12px;padding:12px;background:#f5f5f5;border:1px solid #ddd;border-radius:4px">
        <div style="font-size:14px;font-weight:600;margin-bottom:8px;color:#333" id="firmwareStatusText">Loading firmware list...</div>
        <div id="firmwareProgressContainer" style="display:none;margin-top:8px">
          <div class="progress-bar" style="height:20px">
            <div class="progress-fill" id="firmwareProgBar" style="background:#2196f3"></div>
            <div class="progress-text" id="firmwareProgText" style="line-height:20px;font-size:12px">0%</div>
          </div>
        </div>
        <div id="firmwareStatusMessage" style="font-size:13px;color:#666;margin-top:8px"></div>
      </div>
    </div>
  </div>

  <!-- Start Upgrade -->
  <div class="section">
    <div class="section-title">Start Upgrade</div>
    <div style="margin-top:12px">
      <button class="btn-success" id="btnUpd" onclick="handleFlashClick(event)" title="Click to start firmware upgrade">Flash</button>
      <button class="btn-danger" id="btnCan" onclick="cancelUpdate()" style="display:none">Cancel</button>
    </div>
    <div class="progress-container" id="progBox" style="margin-top:20px">
      <div class="progress-bar">
        <div class="progress-fill" id="progBar"></div>
        <div class="progress-text" id="progText">0%</div>
      </div>
    </div>
    <div class="upgrade-status" id="upgradeStatus">Ready to start upgrade</div>
  </div>


  <!-- Status Log -->
  <div class="section">
    <div class="section-title">Status Log
      <label style="float:right;font-size:13px;font-weight:normal;margin:0">
        <input type="checkbox" id="debugMode">Serial Debug Mode
      </label>
    </div>
    <div class="status-log" id="logBox"></div>
  </div>

  <!-- Important Notice -->
  <div class="notice-box">
    <strong>Important Notice:</strong> After completing an firmware upgrade on this page, please refresh the webpage before starting another firmware upgrade.
  </div>
</div>

<script>
/* ========== 配置 ========== */
// GitHub固件仓库地址
const GITHUB_REPO_BASE = 'https://api.github.com/repos/lincukoo/dongle/contents/firmware';
let selectedChip = null; // 'MG21' or 'MG24'
let currentState = 'ready'; // 'ready', 'boot', 'downloading', 'download_success', 'download_failed', 'flashing', 'flash_success', 'flash_failed'

/* ========== 全局变量 ========== */
// 注意：reader是全局变量，在connectPort中创建，其他地方直接使用
// 如果reader done了，重新获取后要更新这个全局变量
let port = null;
let reader = null;
let writer = null;
let updating = false;
let cnt = 0;
let firmwareBytes = null;
let firmwareFileName = '';
let githubFirmwareUrl = null;
let firmwareCache = {}; // 存储所有已下载的固件文件，key: fileName, value: Uint8Array

/* ========== 日志 ========== */
function log(msg, type = 'info') {
  const box = document.getElementById('logBox');
  const line = document.createElement('div');
  line.className = 'log-entry ' + type;
  line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
  box.appendChild(line);
  box.scrollTop = box.scrollHeight;
}

function logRawData(data, prefix = '') {
  const isDebugMode = document.getElementById('debugMode')?.checked || false;
  if (!isDebugMode) return;
  const text = new TextDecoder('utf-8', { fatal: false }).decode(data);
  const printable = text.replace(/[\x00-\x1F\x7F-\x9F]/g, '.');
  if (printable.trim().length > 0) {
    log(`${prefix}${printable}`, 'info');
  }
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

function updateProgress(p) {
  const bar = document.getElementById('progBar');
  const text = document.getElementById('progText');
  bar.style.width = p + '%';
  if (text) text.textContent = p + '%';
}


// 检查升级条件，返回 { canUpgrade: boolean, errorMessage: string }
// 按顺序检查：1. boot模式 2. 固件选择 3. 固件下载
function checkUpgradeConditions() {
  // 条件1: 检查是否已进入bootloader mode
  // 状态检查：currentState === 'boot'
  if (currentState == 'ready') {
    return {
      canUpgrade: false,
      errorMessage: 'Error: Device is not in bootloader mode. Please reconnect the device and ensure it enters bootloader mode.'
    };
  }
  
  // 条件2: 检查是否已选择具体要升级的固件
  // 状态检查：firmwareFileName 不为空
  if (!firmwareFileName || firmwareFileName === '') {
    return {
      canUpgrade: false,
      errorMessage: 'Error: No firmware file selected. Please select a firmware version from the list.'
    };
  }
  
  // 条件3: 检查固件是否已从GitHub下载完成
  // 状态检查：currentState === 'download_success' 且 firmwareBytes 不为空
  if (currentState !== 'download_success') {
    if (currentState === 'downloading') {
      return {
        canUpgrade: false,
        errorMessage: 'Error: Firmware is still downloading. Please wait for the download to complete.'
      };
    } else {
      return {
        canUpgrade: false,
        errorMessage: 'Error: Firmware has not been downloaded from GitHub. Please select and download firmware first.'
      };
    }
  }
  
  if (!firmwareBytes || firmwareBytes.length === 0) {
    // 尝试从缓存中重新加载
    if (firmwareFileName && firmwareCache[firmwareFileName]) {
      log(`Firmware data missing, reloading from cache: ${firmwareFileName}`, 'warning');
      firmwareBytes = firmwareCache[firmwareFileName];
      log(`Firmware reloaded from cache: ${firmwareFileName} (${firmwareBytes.length} bytes)`, 'success');
    } else {
      log(`Firmware data missing and not in cache. firmwareFileName=${firmwareFileName || 'empty'}, cache keys: ${Object.keys(firmwareCache).join(', ') || 'empty'}`, 'error');
      return {
        canUpgrade: false,
        errorMessage: 'Error: Firmware data is missing. Please select a firmware version from the list again.'
      };
    }
  }
  
  // 所有条件满足
  return {
    canUpgrade: true,
    errorMessage: ''
  };
}

// 处理Flash按钮点击事件
function handleFlashClick(event) {
  const btnUpd = document.getElementById('btnUpd');
  if (!btnUpd) {
    log('Flash button element not found', 'error');
    return;
  }
  
  // 检查升级条件
  const conditions = checkUpgradeConditions();
  
  // 如果条件不满足，显示原因并返回
  if (!conditions.canUpgrade) {
    log(`Flash button clicked but conditions not met: ${conditions.errorMessage}`, 'warning');
    alert(conditions.errorMessage);
    return;
  }
  
  // 条件满足，执行升级
  log('Flash button clicked, all conditions met, starting upgrade...', 'info');
  startUpdate();
}


// 更新固件下载状态显示
function updateFirmwareStatus(text, showProgress = false, progress = 0, message = '') {
  const statusBox = document.getElementById('firmwareStatus');
  const statusText = document.getElementById('firmwareStatusText');
  const progressContainer = document.getElementById('firmwareProgressContainer');
  const progressBar = document.getElementById('firmwareProgBar');
  const progressText = document.getElementById('firmwareProgText');
  const statusMessage = document.getElementById('firmwareStatusMessage');
  
  if (statusBox) {
    statusBox.style.display = 'block';
    if (text.includes('Success') || text.includes('success')) {
      statusBox.style.background = '#e8f5e9';
      statusBox.style.borderColor = '#4caf50';
    } else if (text.includes('Failed') || text.includes('failed') || text.includes('Error')) {
      statusBox.style.background = '#ffebee';
      statusBox.style.borderColor = '#f44336';
    } else {
      statusBox.style.background = '#f5f5f5';
      statusBox.style.borderColor = '#ddd';
    }
  }
  
  if (statusText) statusText.textContent = text;
  if (progressContainer) progressContainer.style.display = showProgress ? 'block' : 'none';
  if (progressBar) progressBar.style.width = progress + '%';
  if (progressText) progressText.textContent = progress + '%';
  if (statusMessage) statusMessage.textContent = message;
}

// 更新芯片选择UI（用于自动检测）
function updateChipSelectionUI(chip) {
  selectedChip = chip;
  
  // 更新按钮样式
  const btnMG21 = document.getElementById('btnMG21');
  const btnMG24 = document.getElementById('btnMG24');
  
  if (chip === 'MG21') {
    if (btnMG21) {
      btnMG21.className = 'btn-chip-active';
      btnMG21.style.background = '#2196f3';
      btnMG21.style.color = '#fff';
    }
    if (btnMG24) {
      btnMG24.className = 'btn-chip-inactive';
      btnMG24.style.background = '#ccc';
      btnMG24.style.color = '#666';
    }
  } else {
    if (btnMG21) {
      btnMG21.className = 'btn-chip-inactive';
      btnMG21.style.background = '#ccc';
      btnMG21.style.color = '#666';
    }
    if (btnMG24) {
      btnMG24.className = 'btn-chip-active';
      btnMG24.style.background = '#2196f3';
      btnMG24.style.color = '#fff';
    }
  }
  
  // 清空固件选择
  const verList = document.getElementById('verList');
  if (verList) {
    verList.innerHTML = '<option value="">Loading firmware list...</option>';
  }
  firmwareBytes = null;
  firmwareFileName = '';
  githubFirmwareUrl = null;
  
  // 隐藏固件状态栏
  const firmwareStatus = document.getElementById('firmwareStatus');
  if (firmwareStatus) firmwareStatus.style.display = 'none';
  
  log(`Auto-detected chip: ${chip}`, 'info');
}

/* ========== GitHub 版本列表 ========== */
let firmwareFiles = []; // 存储固件列表数据

async function loadVersions() {
  if (currentState == 'ready') {
    alert('Error: Device is not in bootloader mode. Please reconnect the device and ensure it enters bootloader mode.');
    return;
  }
  
  const sel = document.getElementById('verList');
  sel.innerHTML = '<option value="">Loading...</option>';
  sel.disabled = true;
  document.getElementById('btnRefresh').disabled = true;
  
  const GITHUB_API = `${GITHUB_REPO_BASE}/${selectedChip}`;
  
  // 显示加载状态
  updateFirmwareStatus('Loading firmware list...', false, 0, '');
  
  try {
    log(`Fetching firmware list from: ${GITHUB_API}`, 'info');
    const r = await fetch(GITHUB_API);
    
    if (!r.ok) {
      let errorText = '';
      try {
        const errorData = await r.json();
        errorText = errorData.message || JSON.stringify(errorData);
      } catch (e) {
        errorText = await r.text();
      }
      log(`GitHub API error: HTTP ${r.status} - ${errorText}`, 'error');
      throw new Error(`HTTP ${r.status}: ${r.statusText}`);
    }
    
    const data = await r.json();
    log(`GitHub API response received, type: ${typeof data}, isArray: ${Array.isArray(data)}`, 'info');
    
    // 检查响应格式（参考ref实现）
    if (!Array.isArray(data)) {
      log(`Invalid GitHub API response format: expected array, got ${typeof data}. Response: ${JSON.stringify(data).substring(0, 200)}`, 'error');
      throw new Error('Invalid response format: expected array');
    }
    
    log(`Found ${data.length} items in GitHub repository`, 'info');
    
    // 过滤并排序固件文件（参考ref实现）
    firmwareFiles = data.filter(f => f.name && (f.name.endsWith('.gbl') || f.name.endsWith('.bin')))
      .map(f => ({
        name: f.name,
        url: f.download_url,
        size: f.size,
        sha: f.sha
      }))
      .sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
    
    log(`Filtered to ${firmwareFiles.length} firmware files`, 'info');
    
    if (firmwareFiles.length === 0) {
      log('No firmware files found in GitHub repository', 'warning');
      sel.innerHTML = '<option value="">No firmware files</option>';
      return;
    }
    
    sel.innerHTML = '<option value="">Please select version</option>';
    firmwareFiles.forEach(f => {
      const opt = document.createElement('option');
      opt.value = f.url;
      const sizeText = f.size ? ` (${(f.size / 1024).toFixed(1)} KB)` : '';
      opt.textContent = f.name + sizeText;
      opt.dataset.size = f.size;
      opt.dataset.name = f.name; // 存储原始文件名，方便后续使用
      sel.appendChild(opt);
    });
    sel.disabled = false;
    document.getElementById('btnRefresh').disabled = false;
    
    log(`Firmware list loaded successfully: ${firmwareFiles.length} files`, 'success');
    updateFirmwareStatus(`Firmware list loaded successfully: ${firmwareFiles.length} files`, true, 0, 'Downloading all firmware files...');
    currentState = 'downloading';
    
    // 自动下载所有固件文件
    log(`Starting to download all ${firmwareFiles.length} firmware files...`, 'info');
    await downloadAllFirmwareFiles();
  } catch (e) {
    log(`Failed to load GitHub firmware list: ${e.message}`, 'error');
    if (e.stack) {
      log(`Error stack: ${e.stack.split('\n')[0]}`, 'error');
    }
    sel.innerHTML = '<option value="">Load failed</option>';
    sel.disabled = false;
    document.getElementById('btnRefresh').disabled = false;
    firmwareFiles = [];
    updateFirmwareStatus(`Failed to load firmware list: ${e.message}`, false, 0, 'Please click Refresh to retry');
    currentState = 'download_failed';
  }
}

// 下载所有固件文件到缓存
async function downloadAllFirmwareFiles() {
  if (firmwareFiles.length === 0) {
    log('No firmware files to download', 'warning');
    return;
  }
  
  firmwareCache = {}; // 清空缓存
  let successCount = 0;
  let failCount = 0;
  const totalFiles = firmwareFiles.length;
  
  for (let i = 0; i < firmwareFiles.length; i++) {
    const file = firmwareFiles[i];
    const fileSizeKB = file.size ? (parseInt(file.size) / 1024).toFixed(2) : 'unknown';
    
    log(`Downloading firmware ${i + 1}/${totalFiles}: ${file.name} (${fileSizeKB} KB)...`, 'info');
    updateFirmwareStatus(`Downloading firmware ${i + 1}/${totalFiles}: ${file.name}`, true, Math.round((i / totalFiles) * 100), `Progress: ${i}/${totalFiles} files`);
    
    try {
      const response = await fetch(file.url);
      if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      
      const contentLength = response.headers.get('content-length');
      const total = contentLength ? parseInt(contentLength, 10) : 0;
      const reader = response.body.getReader();
      const chunks = [];
      let receivedLength = 0;
      
      // 下载文件数据
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        
        chunks.push(value);
        receivedLength += value.length;
      }
      
      // 合并所有chunks
      const allChunks = new Uint8Array(receivedLength);
      let position = 0;
      for (const chunk of chunks) {
        allChunks.set(chunk, position);
        position += chunk.length;
      }
      
      // 存储到缓存
      firmwareCache[file.name] = allChunks;
      successCount++;
      log(`✓ Downloaded ${file.name} (${allChunks.length} bytes, ${(allChunks.length / 1024).toFixed(2)} KB)`, 'success');
    } catch (error) {
      failCount++;
      log(`✗ Failed to download ${file.name}: ${error.message}`, 'error');
    }
  }
  
  // 更新状态
  if (successCount > 0) {
    currentState = 'download_success';
    log(`All firmware files downloaded: ${successCount} success, ${failCount} failed`, 'success');
    log(`Cache status: ${Object.keys(firmwareCache).length} files stored in cache: ${Object.keys(firmwareCache).join(', ')}`, 'success');
    updateFirmwareStatus(`All firmware files downloaded: ${successCount} success, ${failCount} failed`, false, 100, `Please select a firmware version to flash`);
  } else {
    currentState = 'download_failed';
    log(`Failed to download all firmware files`, 'error');
    updateFirmwareStatus(`Failed to download all firmware files`, false, 0, 'Please click Refresh to retry');
  }
}

document.getElementById('verList').addEventListener('change', async e => {
  // 允许选择固件的状态：
  // - 'ready': 初始状态
  // - 'entered_boot_mode' 或 'boot': 已进入boot模式
  // - 'download_success': 固件已下载成功，允许重新选择
  // - 'download_failed': 下载失败，允许重新选择
  // - 'flash_success': 刷写成功，允许选择新固件进行下一次升级
  // - 'flash_failed': 刷写失败，允许重新选择
  // 不允许的状态：
  // - 'downloading': 正在下载，不允许中断
  // - 'flashing': 正在刷写，不允许中断
  // if (!checkState(['ready', 'entered_boot_mode', 'boot', 'download_success', 'download_failed', 'flash_success', 'flash_failed'], 'select firmware version')) {
  //   e.target.value = '';
  //   return;
  // }
  
  const url = e.target.value;
  if (!url) {
    firmwareBytes = null;
    firmwareFileName = '';
    githubFirmwareUrl = null;
    return;
  }
  
  // 从dataset获取原始文件名（不包含大小信息）
  const selectedOption = e.target.selectedOptions[0];
  const fileName = selectedOption.dataset.name || selectedOption.text.split(' (')[0]; // 如果没有dataset.name，从text中提取
  const fileSize = selectedOption.dataset.size;
  
  // 固件选择完成，从缓存中获取对应的固件数据
  firmwareFileName = fileName; // 使用原始文件名，不包含大小
  githubFirmwareUrl = url;
  log(`Firmware selected: ${fileName}`, 'info');
  document.getElementById('fileInput').value = '';
  
  // 从缓存中获取固件数据
  if (firmwareCache[fileName]) {
    firmwareBytes = firmwareCache[fileName];
    const fileSizeKB = firmwareBytes.length / 1024;
    log(`✓ Firmware loaded from cache: ${fileName} (${firmwareBytes.length} bytes, ${fileSizeKB.toFixed(2)} KB)`, 'success');
    log(`✓ Firmware data is ready for flashing. firmwareBytes exists: ${!!firmwareBytes}, length: ${firmwareBytes.length}`, 'success');
    log(`✓ Cache status: ${Object.keys(firmwareCache).length} files in cache`, 'info');
    updateFirmwareStatus(`Firmware selected: ${fileName}`, false, 100, `Size: ${fileSizeKB.toFixed(2)} KB - Ready to flash`);
    currentState = 'download_success';
  } else {
    log(`✗ Firmware not found in cache: ${fileName}`, 'error');
    log(`✗ Cache status: ${Object.keys(firmwareCache).length} files in cache. Available files: ${Object.keys(firmwareCache).join(', ') || 'none'}`, 'error');
    firmwareBytes = null;
    firmwareFileName = '';
    githubFirmwareUrl = null;
    updateFirmwareStatus(`Firmware not found in cache: ${fileName}`, false, 0, 'Please click Refresh to reload firmware files');
    currentState = 'download_failed';
  }
});


/* ========== 串口 ========== */
let portWatcher = null; // 串口监听器
let knownPorts = new Set(); // 已知的串口集合

// 启动串口监听（监听串口断开）
function startPortWatcher() {
  if (!('serial' in navigator)) return;
  
  try {
    if (navigator.serial.addEventListener) {
      // 监听串口断开事件
      navigator.serial.addEventListener('disconnect', async (event) => {
        // 如果当前连接的串口断开了，自动断开连接并清理状态
        if (port && event.target === port) {
          log('Serial port disconnected, cleaning up...', 'warning');
          await handlePortDisconnect();
        }
      });
    }
  } catch (error) {
    // 忽略错误
  }
}

async function connectPort() {
  // 如果已连接，不允许重复连接
  if (port) {
    log('Serial port already connected, please disconnect first', 'warning');
    return;
  }
  
  if (!('serial' in navigator)) {
    log('Please use Chrome/Edge 89+', 'error');
    return;
  }
  
  // 每次重新连接时，清空之前下载的固件缓存，避免芯片切换时历史数据导致异常
  firmwareBytes = null;
  firmwareFileName = '';
  githubFirmwareUrl = null;
  firmwareFiles = [];
  firmwareCache = {}; // 清空固件缓存
  
  // 清空固件选择下拉框
  const verList = document.getElementById('verList');
  if (verList) {
    verList.innerHTML = '<option value="">Please wait for chip detection...</option>';
    verList.disabled = true;
  }
  
  // 隐藏固件状态栏
  const firmwareStatus = document.getElementById('firmwareStatus');
  if (firmwareStatus) {
    firmwareStatus.style.display = 'none';
  }
  
  // 更新Flash按钮状态
  
  log('Cleared previous firmware cache for new connection', 'info');
  
  try {
    // 直接弹出选择窗口
    const selectedPort = await navigator.serial.requestPort({
      filters: [] // 显示所有可用串口
    });
    
    port = selectedPort;
  
  // 固定串口参数：115200, 8N1
  await port.open({ baudRate: 115200, dataBits: 8, stopBits: 1, parity: 'none' });

  writer = port.writable.getWriter();
  // 创建全局reader，后续所有地方都使用这个全局reader
  reader = port.readable.getReader();
  
    log('Serial port connected (115200, 8N1)', 'success');
    
    const statusBox = document.getElementById('connectionStatus');
    const statusText = document.getElementById('portStatusText');
    const helpBox = document.getElementById('connectionHelp');
    if (statusBox && statusText) {
      statusBox.style.display = 'block';
      statusBox.className = 'connection-status';
      statusText.textContent = '';
      statusText.style.color = '#2e7d32';
      const chipInfo = document.getElementById('chipInfo');
      if (chipInfo) chipInfo.textContent = '';
    }
    if (helpBox) {
      helpBox.style.display = 'none';
    }
    
    document.getElementById('btnConn').style.display = 'none';
    document.getElementById('btnDis').style.display = 'inline-block';
    
    // 连接成功后，自动进入boot模式检测
    // 逻辑：每次点击Connect后，连接成功就进入boot检测，持续接收数据检查是否包含"Bootloader Version"
    log('Serial port connected, entering bootloader mode detection...', 'info');
    try {
      await enterUpgradeModeForConnection();
      log('Boot mode detected successfully', 'success');
    } catch (e) {
      log(`Failed to enter bootloader mode: ${e.message}`, 'error');
      currentState = 'ready';
      
      // 显示错误提示，告诉用户如何操作
      const statusBox = document.getElementById('connectionStatus');
      const bootModeError = document.getElementById('bootModeError');
      if (statusBox && bootModeError) {
        statusBox.style.display = 'none'; // 隐藏外层框
        bootModeError.style.display = 'block';
      }
      
      // Boot模式检测失败，不影响连接状态，但Flash按钮保持禁用
    }
    
  } catch (error) {
    if (error.name === 'NotFoundError') {
      log('No serial port selected', 'error');
    } else if (error.name === 'SecurityError') {
      log('Serial port access denied', 'error');
    } else if (error.name === 'AbortError') {
      log('User cancelled serial port selection', 'info');
    } else {
      log(`Failed to connect serial port: ${error.message}`, 'error');
    }
    
    // 清理状态
    port = null;
    writer = null;
    reader = null;
    const statusBox = document.getElementById('connectionStatus');
    const helpBox = document.getElementById('connectionHelp');
    if (statusBox) {
      statusBox.style.display = 'none';
    }
    if (helpBox) {
      helpBox.style.display = 'block';
    }
  }
}

// 处理串口断开（统一处理函数）
async function handlePortDisconnect() {
  updating = false;
  
  log('Serial port disconnected detected, cleaning connection state...', 'warning');
  
  // 清理reader
  if (reader) {
    try {
      await reader.cancel();
      await reader.releaseLock();
    } catch (e) {
      // 忽略错误
    }
    reader = null;
  }
  
  // 清理writer
  if (writer) {
    try {
      await writer.close();
      await writer.releaseLock();
    } catch (e) {
      // 忽略错误
    }
    writer = null;
  }
  
  // 清理port
  if (port) {
    try {
      await port.close();
    } catch (e) {
      // 忽略错误
    }
    port = null;
  }
  
  // 更新UI状态
  const statusBox = document.getElementById('connectionStatus');
  const helpBox = document.getElementById('connectionHelp');
  if (statusBox) {
    statusBox.style.display = 'none';
  }
  if (helpBox) {
    helpBox.style.display = 'block';
  }
  
  document.getElementById('btnConn').style.display = 'inline-block';
  document.getElementById('btnDis').style.display = 'none';
  document.getElementById('btnCan').style.display = 'none';
  document.getElementById('progBox').style.display = 'none';
  
  // 隐藏boot检测相关UI
  const bootProgBox = document.getElementById('bootDetectionProgress');
  const bootModeError = document.getElementById('bootModeError');
  if (bootProgBox) bootProgBox.style.display = 'none';
  if (bootModeError) bootModeError.style.display = 'none';
  
  // 重置芯片选择状态
  selectedChip = null;
  const btnMG21 = document.getElementById('btnMG21');
  const btnMG24 = document.getElementById('btnMG24');
  const chipAutoDetectInfo = document.getElementById('chipAutoDetectInfo');
  if (btnMG21) {
    btnMG21.className = 'btn-chip-inactive';
    btnMG21.style.background = '#ccc';
    btnMG21.style.color = '#666';
  }
  if (btnMG24) {
    btnMG24.className = 'btn-chip-inactive';
    btnMG24.style.background = '#ccc';
    btnMG24.style.color = '#666';
  }
  if (chipAutoDetectInfo) {
    chipAutoDetectInfo.textContent = 'Chip model will be automatically detected when entering bootloader mode';
    chipAutoDetectInfo.style.color = '#666';
    chipAutoDetectInfo.style.fontStyle = 'italic';
    chipAutoDetectInfo.style.fontWeight = 'normal';
    chipAutoDetectInfo.style.fontSize = '12px';
  }
  
  // 串口断开，清空所有状态信息，重头来
  log('Clearing all states due to port disconnect...', 'info');
  
  // 清空固件相关状态
  firmwareBytes = null;
  firmwareFileName = '';
  githubFirmwareUrl = null;
  firmwareFiles = [];
  firmwareCache = {}; // 清空固件缓存
  
  // 清空芯片选择状态
  selectedChip = null;
  
  // 重置系统状态
  currentState = 'ready';
  
  log(`All states cleared. currentState: ${currentState}, firmwareFileName: ${firmwareFileName || 'empty'}, firmwareBytes: ${firmwareBytes ? 'exists' : 'null'}`, 'info');
  
  // 清空固件选择下拉框
  const verList = document.getElementById('verList');
  if (verList) {
    verList.innerHTML = '<option value="">Please select chip model first</option>';
    verList.disabled = false;
  }
  
  // 隐藏固件状态栏
  const firmwareStatus = document.getElementById('firmwareStatus');
  if (firmwareStatus) {
    firmwareStatus.style.display = 'none';
  }
  
  
  log('Serial port connection cleared, please reconnect', 'warning');
}

async function disconnectPort() {
  updating = false;
  
  log('Disconnecting serial port...', 'info');
  
  // 先取消所有读取操作，立即中断正在进行的检测
  if (reader) {
    try {
      await reader.cancel();
      await reader.releaseLock();
    } catch (e) {
      // 忽略错误
    }
    reader = null;
  }
  
  // 关闭写入器
  if (writer) {
    try {
    await writer.close();
      await writer.releaseLock();
    } catch (e) {
      // 忽略错误
    }
    writer = null;
  }
  
  // 关闭串口（这会释放串口占用，使其重新出现在选择列表中）
  if (port) {
    try {
      await port.close();
      log('Serial port closed, resources released', 'success');
    } catch (e) {
      // 忽略错误
    }
    port = null;
  }
  
  log('Serial port disconnected, resources released, can reconnect', 'success');
  const statusBox = document.getElementById('connectionStatus');
  const helpBox = document.getElementById('connectionHelp');
  if (statusBox) {
    statusBox.style.display = 'none';
  }
  if (helpBox) {
    helpBox.style.display = 'block';
  }
  
  document.getElementById('btnConn').style.display = 'inline-block';
  document.getElementById('btnDis').style.display = 'none';
  document.getElementById('btnCan').style.display = 'none';
  document.getElementById('progBox').style.display = 'none';
  
  // 隐藏boot检测相关UI
  const bootProgBox = document.getElementById('bootDetectionProgress');
  const bootModeError = document.getElementById('bootModeError');
  if (bootProgBox) bootProgBox.style.display = 'none';
  if (bootModeError) bootModeError.style.display = 'none';
  
  // 重置芯片选择状态
  selectedChip = null;
  const btnMG21 = document.getElementById('btnMG21');
  const btnMG24 = document.getElementById('btnMG24');
  const chipAutoDetectInfo = document.getElementById('chipAutoDetectInfo');
  if (btnMG21) {
    btnMG21.className = 'btn-chip-inactive';
    btnMG21.style.background = '#ccc';
    btnMG21.style.color = '#666';
  }
  if (btnMG24) {
    btnMG24.className = 'btn-chip-inactive';
    btnMG24.style.background = '#ccc';
    btnMG24.style.color = '#666';
  }
  if (chipAutoDetectInfo) {
    chipAutoDetectInfo.textContent = 'Chip model will be automatically detected when entering bootloader mode';
    chipAutoDetectInfo.style.color = '#666';
    chipAutoDetectInfo.style.fontStyle = 'italic';
    chipAutoDetectInfo.style.fontWeight = 'normal';
    chipAutoDetectInfo.style.fontSize = '12px';
  }
  
  // 串口断开，清空所有状态信息，重头来
  log('Clearing all states due to port disconnect...', 'info');
  
  // 清空固件相关状态
  firmwareBytes = null;
  firmwareFileName = '';
  githubFirmwareUrl = null;
  firmwareFiles = [];
  firmwareCache = {}; // 清空固件缓存
  
  // 重置系统状态
  currentState = 'ready';
  
  log(`All states cleared. currentState: ${currentState}, firmwareFileName: ${firmwareFileName || 'empty'}, firmwareBytes: ${firmwareBytes ? 'exists' : 'null'}`, 'info');
  
  // 清空固件选择下拉框
  const verList = document.getElementById('verList');
  if (verList) {
    verList.innerHTML = '<option value="">Please select chip model first</option>';
    verList.disabled = false;
  }
  
  // 隐藏固件状态栏
  const firmwareStatus = document.getElementById('firmwareStatus');
  if (firmwareStatus) {
    firmwareStatus.style.display = 'none';
  }
  
}

/* ========== Boot模式检测（用于连接时检测） ========== */
// 逻辑参考 enterUpgradeMode：只读不写，检测欢迎菜单中的 "Bootloader Version"/"bootloader version"
async function enterUpgradeModeForConnection() {
  const startTime = Date.now();
  const timeout = 15 * 1000; // 20秒超时
  let receivedData = '';
  let bootModeDetected = false;
  
  // 显示进度条
  const bootProgBox = document.getElementById('bootDetectionProgress');
  const bootProgBar = document.getElementById('bootProgBar');
  const bootProgText = document.getElementById('bootProgText');
  const bootModeError = document.getElementById('bootModeError');
  
  if (bootProgBox) bootProgBox.style.display = 'block';
  if (bootModeError) bootModeError.style.display = 'none';
  
  log('Detecting bootloader mode, waiting for bootloader version info to identify chip model...', 'info');
  
  // 确保port可读
  if (!port || !port.readable) {
    throw new Error('Serial port not readable, cannot detect bootloader mode');
  }
  // 确保全局reader存在
  if (!reader) {
    if (!port || !port.readable) {
      throw new Error('Serial port not readable, cannot detect bootloader mode');
    }
    reader = port.readable.getReader();
  }
  
  // 启动进度条更新
  const progressInterval = setInterval(() => {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(100, Math.round((elapsed / timeout) * 100));
    if (bootProgBar) bootProgBar.style.width = progress + '%';
    if (bootProgText) bootProgText.textContent = progress + '%';
  }, 100);
  
  try {
    while (Date.now() - startTime < timeout) {
      // 检查是否已断开连接，如果是则立即退出
      if (!port || !port.readable || !reader) {
        log('Port disconnected during bootloader detection, exiting...', 'info');
        break;
      }
      
      // 在 2 秒窗口内持续读取，逻辑参考 enterUpgradeMode
      const checkStart = Date.now();
      let hasReceivedData = false;
      
      try {
          const { value, done } = await Promise.race([
            reader.read(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 5000))
          ]);
          
          if (done) {
            // reader 结束，检查是否已断开连接
            if (!port || !port.readable) {
              log('Port disconnected during bootloader detection, exiting...', 'info');
              break;
            }
            // 尝试重新获取
            try {
              await reader.releaseLock();
            } catch (e) {
              // 忽略释放错误
            }
            if (port && port.readable) {
              reader = port.readable.getReader();
              log('Reader re-acquired for bootloader detection', 'info');
            } else {
              log('Cannot re-acquire reader, port may be disconnected', 'warning');
              break;
            }
            continue;
          }
          
          if (value && value.length > 0) {
            hasReceivedData = true;
            logRawData(value, '[bootloader detection received] ');
            const text = new TextDecoder('utf-8', { fatal: false }).decode(value);
            receivedData += text;
            
            // 打印接收到的原始数据片段
            // log(`Bootloader detection received (${value.length} bytes): ${text.substring(0, 100)}`, 'info');
            
            // 检测芯片类型：优先检测 MG24，然后检测 MG21
            const lowerData = receivedData.toLowerCase();
            let detectedChip = null;
            
            // 检测 MG24: "MG24_Bootloader_Version" (使用下划线)
            if (lowerData.includes('mg24_bootloader_version')) {
              detectedChip = 'MG24';
              bootModeDetected = true;
              log('✓ Detected MG24 bootloader menu ("MG24_Bootloader_Version"), device is in bootloader mode', 'success');
            }
            // 检测 MG21: 包含 "bootloader version" 但不包含 "mg24"
            else if (lowerData.includes('bootloader version') && !lowerData.includes('mg24')) {
              detectedChip = 'MG21';
              bootModeDetected = true;
              log('✓ Detected MG21 bootloader menu ("Bootloader Version"), device is in bootloader mode', 'success');
            }
            
            if (bootModeDetected && detectedChip) {
              // 进入boot成功，设置状态
              currentState = 'entered_boot_mode';
              log(`Bootloader mode entered successfully. State set to: ${currentState}`, 'success');
              
              // 自动选择芯片并更新UI
              selectedChip = detectedChip;
              updateChipSelectionUI(detectedChip);
              
              // 隐藏进度条，显示成功
              clearInterval(progressInterval);
              if (bootProgBox) bootProgBox.style.display = 'none';
              if (bootModeError) bootModeError.style.display = 'none';
              
              // 更新连接状态显示
              const statusBox = document.getElementById('connectionStatus');
              const statusText = document.getElementById('portStatusText');
              const chipInfo = document.getElementById('chipInfo');
              
              if (statusBox) {
                statusBox.style.display = 'block';
                statusBox.className = 'connection-status';
                statusBox.style.background = '#e8f5e9';
                statusBox.style.borderColor = '#4caf50';
                statusBox.style.color = '#2e7d32';
              }
              
              if (statusText) {
                statusText.innerHTML = 'Successfully entered bootloader mode';
                statusText.style.color = '#2e7d32';
                statusText.style.fontWeight = '600';
                statusText.style.fontSize = '14px';
                statusText.style.display = 'block';
                statusText.style.visibility = 'visible';
                statusText.style.opacity = '1';
                statusText.style.marginBottom = '4px';
              }
              
              if (chipInfo) {
                chipInfo.textContent = `Detected chip: ${detectedChip}`;
                chipInfo.style.display = 'block';
                chipInfo.style.color = '#2e7d32';
                chipInfo.style.fontSize = '13px';
                chipInfo.style.marginTop = '4px';
              }
              
              // 更新芯片自动检测信息
              const chipAutoDetectInfo = document.getElementById('chipAutoDetectInfo');
              if (chipAutoDetectInfo) {
                chipAutoDetectInfo.textContent = `Auto-detected chip: ${detectedChip}`;
                chipAutoDetectInfo.style.color = '#4caf50';
                chipAutoDetectInfo.style.fontStyle = 'normal';
                chipAutoDetectInfo.style.fontWeight = '600';
                chipAutoDetectInfo.style.fontSize = '12px';
              }
              
              // 自动加载对应芯片的固件列表
              log(`Auto-loading firmware list for ${detectedChip}...`, 'info');
              setTimeout(() => {
                loadVersions();
              }, 500);
              
              
              return true;
            }
            
            // 限制缓存长度，避免无限增长
            if (receivedData.length > 2000) {
              receivedData = receivedData.slice(-1000);
            }
          }
        } catch (e) {
          if (e.message === 'timeout') {
            // 单次 5000ms 超时，继续在该 2 秒窗口内读
            continue;
          } else if (e.message.includes('cancel') || e.name === 'AbortError') {
            // reader 被取消，说明正在断开连接，立即退出
            log('Reader cancelled, exiting bootloader detection...', 'info');
            break;
          } else {
            // 检查是否 port 已断开
            if (!port || !port.readable) {
              log('Port disconnected, exiting bootloader detection...', 'info');
              break;
            }
            log(`[bootloader detection read error] ${e.message}`, 'error');
          }
        }
      
      // 2 秒窗口结束，根据是否收到数据输出提示
      if (!hasReceivedData) {
        log('Bootloader detection: no data received within 2 seconds, continue waiting...', 'info');
      } else {
        log('Bootloader detection: data received but no "Bootloader Version"/"Bootloader Version", continue waiting...', 'info');
      }
    }
    
    // 超时处理
    clearInterval(progressInterval);
    if (bootProgBox) bootProgBox.style.display = 'none';
    
    // 只显示错误框，隐藏外层框
    const statusBox = document.getElementById('connectionStatus');
    if (statusBox) {
      statusBox.style.display = 'none'; // 隐藏外层框
    }
    if (bootModeError) bootModeError.style.display = 'block';
    
    log('Bootloader mode detection timeout: bootloader menu not detected within 20 seconds', 'error');
    throw new Error('Bootloader menu not detected within 20 seconds. Please ensure the dongle is in bootloader mode (hold boot, plug in, release after 3s, LED off).');
  } catch (e) {
    clearInterval(progressInterval);
    if (bootProgBox) bootProgBox.style.display = 'none';
    if (!bootModeDetected) {
      // 只显示错误框，隐藏外层框
      const statusBox = document.getElementById('connectionStatus');
      if (statusBox) {
        statusBox.style.display = 'none'; // 隐藏外层框
      }
      if (bootModeError) bootModeError.style.display = 'block';
    }

    throw e;
  }
}

/* ========== 升级流程：进入升级模式（用于升级时） ========== */
async function enterUpgradeMode() {
  const startTime = Date.now();
  const timeout = 5 * 60 * 1000; // 5分钟超时
  let receivedData = '';
  let uploadGblDetected = false;
  
  log('Sending "1\\r\\n" command, waiting for "begin upload"...', 'info');
  
  // 确保reader可用
  if (!reader) {
    if (!port || !port.readable) {
      throw new Error('Serial port not readable, cannot enter upgrade mode');
    }
    reader = port.readable.getReader();
  }
  
  while (Date.now() - startTime < timeout && updating) {
    // 如果还没检测到"begin upload"，发送"1\r\n"
    if (!uploadGblDetected) {
      try {
        const cmd = new TextEncoder().encode('1\r\n');
        await writer.write(cmd);
        logRawData(cmd, '[发送] ');
        // 等待一小段时间，让设备有时间响应
        await delay(100);
      } catch (e) {
        log(`Send failed: ${e.message}`, 'error');
        throw e;
      }
    }
    
    // 持续读取串口数据，等待响应
    const checkStart = Date.now();
    let hasReceivedData = false;
    
    while (Date.now() - checkStart < 2000 && updating) {
      try {
        const { value, done } = await Promise.race([
          reader.read(),
          new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 500))
        ]);
        
        if (done) {
          // 尝试重新获取reader
          if (port && port.readable) {
            reader = port.readable.getReader();
          } else {
            throw new Error('Serial port reading ended and cannot re-acquire reader');
          }
          continue;
        }
        
        if (value && value.length > 0) {
          hasReceivedData = true;
          logRawData(value, '[接收] ');
          const text = new TextDecoder('utf-8', { fatal: false }).decode(value);
          receivedData += text;
          
          // 第一步：检测"begin upload"（不区分大小写）
          const lowerData = receivedData.toLowerCase();
          if (lowerData.includes('begin upload') || lowerData.includes('beginupload')) {
            uploadGblDetected = true;
            log('✓ Detected "begin upload", waiting 2 seconds before entering XModem transfer...', 'success');
            // 等待2秒，让设备准备就绪
            await new Promise(resolve => setTimeout(resolve, 2000));
            // 返回，停止所有串口发送，进入XModem传输
            return true;
          }
        }
      } catch (e) {
        if (e.message === 'timeout') {
          // 超时是正常的，继续等待
          continue;
        } else if (!e.message.includes('cancel')) {
          log(`Reading error: ${e.message}`, 'error');
          // 如果是其他错误，尝试继续
        }
      }
    }
    
    // 2秒内没检测到"begin upload"
    if (!hasReceivedData) {
      log('No data received within 2 seconds, resending "1\\r\\n"...', 'warning');
    } else {
      log(`"begin upload" not detected within 2 seconds (data received but not matched), resending "1\\r\\n"...`, 'info');
      // 保留部分数据，但限制长度避免无限增长
      if (receivedData.length > 1000) {
        receivedData = receivedData.slice(-500);
      }
    }
  }
  
  // 超时
  if (!uploadGblDetected) {
    throw new Error('"begin upload" not detected within 5 minutes, upgrade failed. Last received data: ' + (receivedData || 'none'));
  } else {
    throw new Error('Detected "begin upload" but did not receive XModem start signal, upgrade failed');
  }
}

/* ========== XModem 协议 ========== */
const SOH = 0x01, EOT = 0x04, ACK = 0x06, NAK = 0x15, CAN = 0x18, CTRL_C = 0x03, CMD_C = 0x43;

// Bootloader CRC16计算函数（设备专用算法）
// 完全按照C代码实现，确保每一步都与bootloader一致
function btl_crc16(newByte, prevResult) {
  // 第1步：字节交换 (prevResult >> 8) | (prevResult << 8)
  // 在C中，uint16_t左移8位会自动截断到16位
  // 高8位移到低8位，低8位移到高8位
  prevResult = ((prevResult >>> 8) | ((prevResult & 0xFF) << 8)) & 0xFFFF;
  
  // 第2步：与输入字节异或
  prevResult = (prevResult ^ newByte) & 0xFFFF;
  
  // 第3步：与低字节右移4位异或 (prevResult & 0xff) >> 4
  prevResult = (prevResult ^ ((prevResult & 0xff) >>> 4)) & 0xFFFF;
  
  // 第4步：与高字节左移4位异或 (prevResult << 8) << 4
  // 在C中：(prevResult << 8) 将低8位移到高8位，然后 << 4 再左移4位
  // 相当于：低8位左移4位后放到高8位，低4位变成0
  // 在JavaScript中需要确保16位截断
  const temp = (prevResult << 8) & 0xFFFF;  // 低8位移到高8位
  prevResult = (prevResult ^ ((temp << 4) & 0xFFFF)) & 0xFFFF;
  
  // 第5步：复杂的位操作
  // ((uint8_t) ((uint8_t) ((uint8_t) (prevResult & 0xff)) << 5))
  // | ((uint16_t) ((uint8_t) ((uint8_t) (prevResult & 0xff)) >> 3) << 8)
  const lowByte = prevResult & 0xff;
  // part1: 低字节左移5位，然后截断到8位
  const part1 = ((lowByte << 5) & 0xff);
  // part2: 低字节右移3位，然后左移8位（放到高8位），截断到16位
  const part2 = (((lowByte >>> 3) & 0xff) << 8) & 0xFFFF;
  prevResult = (prevResult ^ (part1 | part2)) & 0xFFFF;
  
  return prevResult & 0xFFFF;
}

// 计算整个缓冲区的CRC16
function btl_crc16Stream(buffer, prevResult = 0) {
  let result = prevResult;
  for (let i = 0; i < buffer.length; i++) {
    result = btl_crc16(buffer[i], result);
  }
  return result;
}

async function writePacket(n, dat) {
  // XModem-CRC数据包格式：SOH + 包序号 + 包序号补码 + 128字节数据 + CRC16(2字节)
  // 确保数据包正好是128字节
  if (dat.length !== 128) {
    throw new Error(`数据包大小错误：期望128字节，实际${dat.length}字节`);
  }
  
  const packetNum = n & 0xff;
  const packetNumComplement = (0xff - packetNum) & 0xff;
  
  // 验证包序号和补码
  if ((packetNum + packetNumComplement) & 0xff !== 0xff) {
    throw new Error(`包序号补码错误：包序号=${packetNum}, 补码=${packetNumComplement}`);
  }
  
  const head = new Uint8Array([SOH, packetNum, packetNumComplement]);
  
  // 计算CRC16：对128字节数据计算CRC16（使用设备专用算法）
  const crc16 = btl_crc16Stream(dat, 0);
  const crcHigh = (crc16 >> 8) & 0xff;  // CRC高字节
  const crcLow = crc16 & 0xff;           // CRC低字节
  
  // 构建完整数据包：3字节头部 + 128字节数据 + 2字节CRC16 = 133字节
  const pkt = new Uint8Array(133);
  pkt.set(head, 0);
  pkt.set(dat, 3);
  pkt[131] = crcHigh;
  pkt[132] = crcLow;
  
  // 验证数据包格式
  if (pkt[0] !== SOH) {
    throw new Error(`数据包格式错误：第一个字节应该是SOH(0x01)，实际是0x${pkt[0].toString(16).padStart(2, '0')}`);
  }
  if (pkt[1] !== packetNum) {
    throw new Error(`数据包格式错误：包序号不匹配`);
  }
  if (pkt[2] !== packetNumComplement) {
    throw new Error(`数据包格式错误：包序号补码不匹配`);
  }
  // 验证数据包格式：SOH + 包序号 + 补码 + 128字节数据 + 2字节CRC16 = 133字节
  if (pkt.length !== 133) {
    throw new Error(`数据包长度错误：期望133字节，实际${pkt.length}字节`);
  }
  if (pkt[0] !== SOH) {
    throw new Error(`数据包格式错误：第一个字节应该是SOH(0x01)，实际是0x${pkt[0].toString(16).padStart(2, '0')}`);
  }
  if (pkt[1] !== packetNum) {
    throw new Error(`数据包格式错误：包序号不匹配，期望${packetNum}，实际${pkt[1]}`);
  }
  if (pkt[2] !== packetNumComplement) {
    throw new Error(`数据包格式错误：包序号补码不匹配，期望${packetNumComplement}，实际${pkt[2]}`);
  }
  
  // 确保一次性发送完整数据包（133字节）
  // 在发送前再次验证第一个字节
  if (pkt[0] !== 0x01) {
    throw new Error(`发送前验证失败：数据包第一个字节不是0x01，实际是0x${pkt[0].toString(16).padStart(2, '0')}`);
  }
  
  // 确保writer准备好，然后一次性写入完整数据包
  await writer.ready;
  
  // 一次性写入完整数据包（133字节）
  // 注意：Web Serial API的writer.write()可能不是原子操作，
  // 底层驱动可能会将大数据包分片发送，这是底层行为，应用层无法完全控制
  // 使用强制刷新机制确保数据包完整发送
  await writer.write(pkt);
  
  // 强制刷新：关闭writer并重新获取，这样可以强制底层驱动刷新缓冲区
  // 这是确保数据包完整发送的最可靠方法
  // 关闭writer会强制所有待发送的数据立即刷新到硬件
  await writer.close();
  writer = port.writable.getWriter();
  
  // 等待writer准备好，确保新的writer已初始化
  await writer.ready;
  
  // 验证数据包已发送（通过检查pkt数组，确保没有被修改）
  if (pkt[0] !== SOH) {
    throw new Error(`发送后验证失败：数据包第一个字节被修改，应该是SOH(0x01)，实际是0x${pkt[0].toString(16).padStart(2, '0')}`);
  }
  
  // 数据包已发送，等待ACK（不打印详细日志，避免日志过多）
}

async function sendEOT() {
  log('Sending EOT signal (0x04)...', 'info');
  
  // 确保writer准备好
  await writer.ready;
  
  // 发送 EOT (0x04) 信号，表示传输结束
  await writer.write(new Uint8Array([EOT]));
  
  // 强制刷新：关闭writer并重新获取，确保EOT信号立即发送
  await writer.close();
  writer = port.writable.getWriter();
  await writer.ready;
  
  // 等待一小段时间，确保 bootloader 处理完成
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // 发送重启指令 '2\r\n'
  log('Sending restart command "2\\r\\n"...', 'info');
  await writer.ready;
  await writer.write(new Uint8Array([0x32, 0x0D, 0x0A]));
  
  // 强制刷新重启指令
  await writer.close();
  writer = port.writable.getWriter();
  await writer.ready;
}

// 从内存数据发送（本地文件）
async function sendXModem(data) {
  const pkt = 128;
  let num = 1, off = 0, retries;
  
  log('Starting XModem transfer, waiting for receiver start signal (NAK or C)...', 'info');
  
  // 等待接收方发送启动信号（NAK或'C'）
  let startSignalReceived = false;
  const startTimeout = 10000; // 10秒超时
  const startTime = Date.now();
  
  log('Waiting for receiver start signal (NAK or C)...', 'info');
  while (!startSignalReceived && (Date.now() - startTime < startTimeout) && updating) {
    try {
      const { value, done } = await Promise.race([
        reader.read(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 1000))
      ]);
      if (done) break;
      if (value) {
        logRawData(value, '[XModem启动信号] ');
        for (let i = 0; i < value.length; i++) {
          if (value[i] === NAK || value[i] === 0x43) { // NAK (0x15) 或 'C' (0x43)
            startSignalReceived = true;
            log(`✓ Received XModem start signal: ${value[i] === NAK ? 'NAK' : 'C'}, starting transfer immediately...`, 'success');
            break; // 立即退出循环，开始发送数据包
          }
        }
      }
    } catch (e) {
      if (e.message !== 'timeout') {
        log(`Error waiting for start signal: ${e.message}`, 'error');
        break;
      }
    }
    
    if (startSignalReceived) {
      break; // 收到启动信号后立即退出，开始发送数据包
    }
  }
  
  if (!startSignalReceived) {
    throw new Error('XModem start signal (NAK or C) not received, cannot start transfer');
  }
  
  log(`Starting data transfer, total length=${data.length} bytes, will be divided into ${Math.ceil(data.length / pkt)} packets`, 'info');
  
  while (off < data.length && updating) {
    // 计算本次要发送的数据块
    const remaining = data.length - off;
    const chunkSize = Math.min(pkt, remaining);
    const chunk = data.slice(off, off + chunkSize);
    
    // 创建128字节的填充数组，初始化为0x1A
    const pad = new Uint8Array(pkt);
    pad.fill(0x1A);
    
    // 复制实际数据到填充数组
    pad.set(chunk, 0);
    
    // 验证数据包大小
    if (pad.length !== 128) {
      throw new Error(`数据包填充错误：期望128字节，实际${pad.length}字节`);
    }
    
    // 验证数据是否正确填充
    const actualDataBytes = pad.slice(0, chunkSize);
    const paddingBytes = pad.slice(chunkSize);
    if (!actualDataBytes.every((b, i) => b === chunk[i])) {
      throw new Error(`数据复制错误`);
    }
    if (!paddingBytes.every(b => b === 0x1A)) {
      throw new Error(`填充数据错误：应该全部是0x1A`);
    }
    
    let ok = false;
    retries = 10;
    const expectedPacketNum = num; // 记录期望的包序号
    while (retries-- && !ok && updating) {
      // 验证包序号没有变化
      if (num !== expectedPacketNum) {
        throw new Error(`包序号错误：期望${expectedPacketNum}，实际${num}`);
      }
      
      // 验证数据包长度
      if (pad.length !== 128) {
        throw new Error(`数据包长度错误：期望128字节，实际${pad.length}字节`);
      }
      
      await writePacket(num, pad);
      
      // 等待ACK响应，最多等待2秒
      // 必须收到ACK(0x06)才能继续，其他响应都需要重发
      let ackReceived = false;
      const ackWaitStartTime = Date.now();
      const ackTimeout = 2000; // 2秒超时
      
      while (!ackReceived && (Date.now() - ackWaitStartTime < ackTimeout) && updating) {
        try {
          const { value, done } = await Promise.race([
            reader.read(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 500))
          ]);
          if (done) {
            // 串口读取结束，重发数据包
            break; // 重发
          }
          if (value && value.length > 0) {
            logRawData(value, '[XModem receive...] ');
            for (let i = 0; i < value.length; i++) {
              if (value[i] === ACK) {
                // 0x06为正常ACK，必须收到ACK才能继续
                ok = true;
                ackReceived = true;
                const progress = Math.min(100, Math.round((off + pkt) / data.length * 100));
                updateProgress(progress);
                log(`✓ Packet ${num} transferred successfully, received ACK (0x06) (${progress}%)`, 'success');
                break; // 收到ACK，退出等待循环
              } else if (value[i] === NAK) {
                // 0x15为NAK，需要重发
                log(`Received NAK (0x15), resending packet ${num}...`, 'info');
                break; // 立即重发，退出等待循环
              } else if (value[i] === CAN) {
                // 0x18为CAN，传输被取消
                throw new Error('收到CAN信号 (0x18)，传输被取消');
              }
              // 其他数据忽略，继续等待ACK
            }
            // 如果收到ACK，退出等待循环
            if (ackReceived) {
              break;
            }
            // 如果收到NAK，退出等待循环，准备重发
            if (value.some(b => b === NAK)) {
              break;
            }
            // 如果收到其他数据，继续等待ACK
          }
        } catch (e) {
          if (e.message === 'timeout') {
            // 500ms超时，继续等待（总超时时间是2秒）
            continue;
          } else if (e.message.includes('CAN')) {
            throw e;
          } else {
            log(`Error waiting for ACK: ${e.message}, continuing to wait...`, 'error');
          }
        }
      }
      
      // 如果2秒内没有收到ACK，标记为超时
      if (!ackReceived && !ok) {
        // 数据包等待ACK超时，重试
      }
      
      // 如果收到NAK或超时，立即重试（不延迟）
      // 只有在重试次数减少时才稍微延迟，避免过快重试
      // if (!ok && retries > 0 && retries < 9) {
      //   await new Promise(resolve => setTimeout(resolve, 100));
      // }
    }
    
    if (!ok) {
      throw new Error(`数据包 ${num} 传输失败：未收到ACK(0x06)`);
    }
    if (!updating) {
      throw new Error('用户取消');
    }
    
    // 只有在收到ACK后才递增包序号和偏移
    num++;
    if (num > 255) num = 0; // 包序号循环（0-255）
    off += pkt;
    
    // 检查是否还有数据要发送
    // 如果已经是最后一包，立即退出循环，发送EOT
    if (off >= data.length) {
      break; // 退出循环，准备发送EOT
    }
  }
  
  // 所有数据包发送完成后，收到最后一包的ACK后，发送EOT信号
  log('All packets sent, sending EOT signal...', 'info');
  await sendEOT();
}

// 从流发送（GitHub在线文件）
async function sendXModemFromStream(stream, totalSize) {
  const pkt = 128;
  let num = 1, retries;
  const streamReader = stream.getReader();
  let buffer = new Uint8Array(0);
  let totalSent = 0;
  
  log('Starting XModem stream transfer, waiting for receiver start signal (NAK or C)...', 'info');
  
  // 等待接收方发送启动信号（NAK或'C'）
  let startSignalReceived = false;
  const startTimeout = 10000; // 10秒超时
  const startTime = Date.now();
  
  // 先清空串口缓冲区，丢弃所有残留数据
  log('Clearing serial port buffer...', 'info');
  try {
    while (true) {
      const { value, done } = await Promise.race([
        reader.read(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 100))
      ]);
      if (done) break;
      if (value) {
        logRawData(value, '[丢弃残留数据] ');
      }
    }
  } catch (e) {
    // 超时表示缓冲区已清空，继续
  }
  
  log('Waiting for receiver start signal (NAK or C)...', 'info');
  while (!startSignalReceived && (Date.now() - startTime < startTimeout) && updating) {
    try {
      const { value, done } = await Promise.race([
        reader.read(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 1000))
      ]);
      if (done) break;
      if (value) {
        logRawData(value, '[XModem启动信号] ');
        for (let i = 0; i < value.length; i++) {
          if (value[i] === NAK || value[i] === 0x43) { // NAK (0x15) 或 'C' (0x43)
            startSignalReceived = true;
            log(`✓ Received XModem start signal: ${value[i] === NAK ? 'NAK' : 'C'}, starting transfer immediately...`, 'success');
            break; // 立即退出循环，开始发送数据包
          }
        }
      }
    } catch (e) {
      if (e.message !== 'timeout') {
        log(`Error waiting for start signal: ${e.message}`, 'error');
        break;
      }
    }
    
    if (startSignalReceived) {
      break; // 收到启动信号后立即退出，开始发送数据包
    }
  }
  
  if (!startSignalReceived) {
    streamReader.releaseLock();
    throw new Error('未收到XModem启动信号（NAK或C），无法开始传输');
  }
  
  try {
    while (updating) {
      // 确保缓冲区有足够的数据
      while (buffer.length < pkt) {
        const { value, done } = await streamReader.read();
        if (done) {
          if (buffer.length === 0) break; // 文件结束
          break;
        }
        if (value) {
          // 合并到缓冲区
          const newBuffer = new Uint8Array(buffer.length + value.length);
          newBuffer.set(buffer);
          newBuffer.set(value, buffer.length);
          buffer = newBuffer;
        }
      }
      
      if (buffer.length === 0) break; // 没有更多数据
      
      // 取一个数据包
      const chunk = buffer.slice(0, pkt);
      const pad = new Uint8Array(pkt);
      pad.set(chunk);
      // 如果数据不足128字节，用0x1A填充剩余部分
      if (chunk.length < pkt) {
        pad.fill(0x1A, chunk.length, pkt);
      }
      
      // 更新缓冲区
      buffer = buffer.slice(pkt);
      
      let ok = false;
      retries = 10;
      while (retries-- && !ok && updating) {
        await writePacket(num, pad);
        
        // 等待ACK，最多等待2秒
        try {
          const { value, done } = await Promise.race([
            reader.read(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 2000))
          ]);
          if (done) break;
          if (value) {
            logRawData(value, '[XModem receive...] ');
            for (let i = 0; i < value.length; i++) {
              if (value[i] === ACK) {
                ok = true;
                totalSent += pkt;
                if (totalSize) {
                  const progress = Math.min(100, Math.round(totalSent / totalSize * 100));
                  updateProgress(progress);
                }
                break;
              } else if (value[i] === NAK || value[i] === CAN) {
                // 收到NAK或CAN，重试
              }
            }
          }
        } catch (e) {
          if (e.message === 'timeout') {
            // 数据包超时，重试
          } else {
            throw e;
          }
        }
        
        if (!ok && retries > 0) await delay(500);
      }
      
      if (!ok) throw new Error(`数据包 ${num} 传输失败`);
      if (!updating) throw new Error('用户取消');
      
      num++;
      if (num > 255) num = 1; // 包序号循环
      
      // 检查是否还有数据要发送
      // 如果缓冲区为空且流已结束，退出循环
      if (buffer.length === 0) {
        // 尝试读取更多数据
        const { value, done } = await streamReader.read();
        if (done) {
          // 所有数据包已发送完成（流结束）
          break; // 退出循环，准备发送EOT
        }
        if (value) {
          // 还有数据，继续处理
          const newBuffer = new Uint8Array(buffer.length + value.length);
          newBuffer.set(buffer);
          newBuffer.set(value, buffer.length);
          buffer = newBuffer;
        }
      }
    }
  } finally {
    streamReader.releaseLock();
  }
  
  // 所有数据包发送完成后，收到最后一包的ACK后，发送EOT信号
  // 正确的流程：发送完所有数据包 → 收到最后一包的ACK (0x06) → 发送EOT (0x04) → 设备返回ACK (0x06)
  log('All packets sent, sending EOT signal...', 'info');
  await sendEOT();
}

/* ========== 升级主流程 ========== */
async function startUpdate() {
  // 添加日志，确认函数被调用
  log('Flash button clicked, starting upgrade check...', 'info');
  
  // 检查串口连接
  if (!port) {
    const errorMsg = 'Error: Serial port not connected. Please connect the device first.';
    log(errorMsg, 'error');
    alert(errorMsg);
    return;
  }
  
  // 检查所有升级条件
  const conditions = checkUpgradeConditions();
  if (!conditions.canUpgrade) {
    log(conditions.errorMessage, 'error');
    alert(conditions.errorMessage);
    return;
  }
  
  // 再次确认固件数据存在（防止在检查和使用之间被清空）
  if (!firmwareBytes || firmwareBytes.length === 0) {
    // 尝试从缓存中重新加载
    if (firmwareFileName && firmwareCache[firmwareFileName]) {
      log(`Firmware data was cleared, reloading from cache: ${firmwareFileName}`, 'warning');
      firmwareBytes = firmwareCache[firmwareFileName];
      log(`Firmware reloaded from cache: ${firmwareFileName} (${firmwareBytes.length} bytes)`, 'success');
    } else {
      const errorMsg = 'Error: Firmware data not available. Please select a firmware version from the list first.';
      log(errorMsg, 'error');
      log(`Debug info: firmwareFileName=${firmwareFileName || 'empty'}, firmwareBytes=${firmwareBytes ? firmwareBytes.length + ' bytes' : 'null'}, currentState=${currentState}`, 'error');
      log(`Debug info: firmwareCache keys: ${Object.keys(firmwareCache).join(', ') || 'empty'}`, 'error');
      alert(errorMsg);
      return;
    }
  }
  
  log(`Firmware data verified: ${firmwareFileName} (${firmwareBytes.length} bytes)`, 'info');
  
  // 检查reader和writer状态
  if (!reader || !writer) {
    log('Serial port reader/writer not ready, please reconnect serial port', 'error');
    return;
  }
  
  // 设置updating标志，这会阻止任何后台EZSP数据读取器
  updating = true;
  
  // 确保reader可用（如果之前被释放，重新获取）
  if (!port.readable) {
    log('Serial port not readable, please reconnect serial port', 'error');
    updating = false;
    return;
  }
  
  // 确保reader是干净的，如果reader被其他地方占用，先释放再重新获取
  try {
    if (reader) {
      // 尝试取消并释放旧的reader
      try {
        await reader.cancel();
        reader.releaseLock();
      } catch (e) {
        // 忽略错误，可能已经释放了
      }
    }
    // 重新获取reader，确保是干净的
    reader = port.readable.getReader();
      log('Re-acquired serial port reader, ready to enter upgrade mode', 'info');
  } catch (e) {
      log(`Unable to get serial port reader: ${e.message}`, 'error');
    updating = false;
    return;
  }
  
  document.getElementById('btnUpd').style.display = 'none';
  document.getElementById('btnCan').style.display = 'inline-block';
  document.getElementById('progBox').style.display = 'block';
  const upgradeStatus = document.getElementById('upgradeStatus');
  if (upgradeStatus) {
    upgradeStatus.textContent = 'Upgrading...';
    upgradeStatus.className = 'upgrade-status';
  }
  updateProgress(0);
  
  try {
    currentState = 'flashing';
    // 设备已经在boot模式，直接开始传输文件
    log('Starting upgrade process...', 'info');
    log(`Reader status: ${reader ? 'OK' : 'Not initialized'}, Writer status: ${writer ? 'OK' : 'Not initialized'}`, 'info');
    
    // 重新进入升级模式（发送"1\r\n"，等待"begin upload"）
    await enterUpgradeMode();
    
    // 步骤2: 立即开始传输文件（固件已在选择时下载到内存）
    log('Device entered upgrade mode, starting file transfer...', 'success');
    
    // 在实际发送数据前，再次检查并恢复固件数据（防止在enterUpgradeMode过程中被清空）
    if (!firmwareBytes || firmwareBytes.length === 0) {
      // 尝试从缓存中重新加载
      if (firmwareFileName && firmwareCache[firmwareFileName]) {
        log(`Firmware data was cleared during upgrade, reloading from cache: ${firmwareFileName}`, 'warning');
        firmwareBytes = firmwareCache[firmwareFileName];
        log(`Firmware reloaded from cache: ${firmwareFileName} (${firmwareBytes.length} bytes)`, 'success');
      } else {
        log(`Error: Firmware data lost during upgrade process. firmwareFileName=${firmwareFileName || 'empty'}, currentState=${currentState}`, 'error');
        log(`Debug info: firmwareCache keys: ${Object.keys(firmwareCache).join(', ') || 'empty'}`, 'error');
        throw new Error('Firmware data not available. Please select a firmware version from the list again.');
      }
    }
    
    // 发送前最后一次验证
    if (!firmwareBytes || firmwareBytes.length === 0) {
      log(`Critical: Firmware data still missing before sendXModem. Attempting final recovery...`, 'error');
      if (firmwareFileName && firmwareCache[firmwareFileName]) {
        firmwareBytes = firmwareCache[firmwareFileName];
        log(`Final recovery successful: ${firmwareFileName} (${firmwareBytes.length} bytes)`, 'success');
      } else {
        throw new Error(`Firmware data not available before transfer. firmwareFileName=${firmwareFileName || 'empty'}, cache has ${Object.keys(firmwareCache).length} files`);
      }
    }
    
    log(`Starting transfer: ${firmwareFileName} (${firmwareBytes.length} bytes, ${(firmwareBytes.length / 1024).toFixed(2)} KB)`, 'info');
    log(`Final verification: firmwareBytes exists=${!!firmwareBytes}, length=${firmwareBytes ? firmwareBytes.length : 0}`, 'info');
    await sendXModem(firmwareBytes);
    
    updateProgress(100);
    const upgradeStatus = document.getElementById('upgradeStatus');
    if (upgradeStatus) {
      upgradeStatus.textContent = 'Upgrade completed successfully';
      upgradeStatus.className = 'upgrade-status success';
    }
    log('Upgrade successful!', 'success');
    currentState = 'flash_success';
  } catch (e) {
    log('Upgrade failed: ' + e.message, 'error');
    if (e.stack) {
      log('Error stack: ' + e.stack.split('\n')[0], 'error');
    }
    updateProgress(0);
    currentState = 'flash_failed';
  } finally {
    updating = false;
    document.getElementById('btnUpd').style.display = 'inline-block';
    document.getElementById('btnCan').style.display = 'none';
  }
}

function cancelUpdate() {
  updating = false;
  log('User cancelled upgrade', 'info');
  document.getElementById('btnUpd').style.display = 'inline-block';
  document.getElementById('btnCan').style.display = 'none';
  document.getElementById('progBox').style.display = 'none';
  const upgradeStatus = document.getElementById('upgradeStatus');
  if (upgradeStatus) {
    upgradeStatus.textContent = 'Ready to start upgrade';
    upgradeStatus.className = 'upgrade-status';
  }
    // 如果是在下载或刷写过程中取消，恢复到下载成功状态（如果之前已下载）
    if (firmwareBytes && currentState !== 'download_failed') {
      currentState = 'download_success';
    } else {
      currentState = 'ready';
  }
}

/* ========== 初始化 ========== */
window.onload = () => { 
  currentState = 'ready';
  // 不再默认选择芯片，等待自动检测
  selectedChip = null;
  // 启动串口监听
  startPortWatcher();
};
window.onbeforeunload = () => { 
  if (port) {
    disconnectPort();
  }
};
</script>
</body>
</html>
